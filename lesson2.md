# Заняття 2. Булева алгебра та умови

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/George_Boole_color.jpg/274px-George_Boole_color.jpg)

## Що таке булева алгебра?

Булева алгебра – це розділ математики, який займається операціями над логічними значеннями та включає двійкові змінні.
Булева алгебра веде свій початок від книги математика Джорджа Буля (Картинка вище) 1854 року.

Основні поняття в бульовій алгебрі це **true** та **false**, вони ж **істина** та **брехня**, та три оператори **not**,
**and**, та **or**. Вони ж **не**, **та** та **або**.

Дуже велика частина програмування будується саме на двійковій алгебрі, та оперує поняттями з цієї алгебри.

Тип **Python boolean** є одним із вбудованих типів даних Python. Він використовується для представлення істинності значення виразу. Наприклад, вираз ``1 < 2`` є ``True``, тоді як вираз ``0 == 1`` є ``False``. Розуміння "
того, як поводяться логічні значення Python, є важливим для якісного програмування на Python.

Запамʼятайте слова **True** та **False** саме з великої літери є ключовими в мові python, і ви не можете використовувати
їх як назву змінної, функції, класса тощо.

Ці поняття є у кожній мові програмування (які використовуються комерційно, можливо є виключення для деяких проектів
зроблених для веселощів) що мені відома.

![](https://i.imgflip.com/55t2ce.jpg)

Такий тип даних зветься **бульовий**, а такі змінні **бульові**

### Нумо розбиратися що це за тип даних.

Може бути лише два значення *True* та *False*

![](https://static.vecteezy.com/system/resources/previews/004/581/253/original/check-and-cross-icon-right-and-wrong-icon-yes-or-no-buttons-true-or-false-good-or-bad-selection-design-design-free-vector.jpg)

Є три опції як змінна може бути булевим значенням

1) Явне створення змінної такого типу

```python
some_true_variable = True
some_false_variable = False
```

2) Приведення типів

Як ви вже знаете, в python є різні типи даних, наприклад, числа строки та булеві значення. Насправді їх набагато більше,
і ми будемо їх вивчати.

Python цє мова з дінамічною та строгою типізацією, тому ми не повинні позначати яку саме змінну ми створюємо, але ми не
можемо скласти або порівняти між собою число та строку.

А що якщо нам потрібно скласти число зі строкою? Наприклад ми маемо змінну зі значенням 45 та іншу зі значенням '47'.
Перша це число, друга це строка. В такому випадку ми маемо два варіанти. Перший скласти змінні як числа, другий скласти
їх як строки. Щоб ми мали таку можливість ми маемо змінити ти одного з них, та далі працювати з одним і тим самим типом
даних. Щоб привести один тип до іншого все що нам потрібно це написати назву типу маленькими літерами, та у дужках
вказати що саме ми хочемо змінити.

```python
my_num = 45  # Це число
my_str = '47'  # Це строка
print(my_num + my_str)  # Викличе помилку!!
print(my_num + int(my_str))  # Роздрукує 92
print(str(my_num) + my_str)  # Роздрукує 4547

my_str_not_number = 'blabla'
int(my_str_not_number)  # Викличе помилку!! Бо ця строка не може буди перетворена на число
```

Так саме і з булеаном, ми можемо перетворити будь що на булеан **bool(anything)**

Для кожного типа даних свої правила перетворення до логічного типу. Для чисел та строк вони такі:

Будь яка не пуста строка перетвориться на **True**

```python
bool('')  # False
bool('asdasd')  # True
empty_string = ''
not_empty_string = 'some text'
bool(empty_string)  # False
bool(not_empty_string)  # True
```

З числами правила не складніші, будь-яке значення яке не дорівнює **0** це True

```python
bool(4)  # True
bool(0)  # False
bool(-3)  # True
positive = 5
negative = -4
zero = 0
bool(positive)  # True
bool(zero)  # False
bool(negative)  # True
bool(positive - 5)  # False
bool(0.0)  # False
```

3) Як результат математичного порівняння або результат деяких ключових слів

#### Математичні порівняння

Для порівняння в python використовує математичні символи:

Можна порівняти числа, строки та інші типи даних які ви будете вивчати

**>** - більше,

```python
result = 5 > 3  # значення змінної буде True
another_result = 3 > 5  # значення змінної буде False
compare_the_same_values = 3 > 3  # значення змінної буде False
small_value = 4
big_value = 6
compare_variables = big_value > small_value  # значення змінної буде True
compare_variables = small_value > big_value  # значення змінної буде False
compare_strings = 'ab' > 'baa'  # значення змінної буде False, бо порівняння зрівнює по абетці, а 'a' раніше в абетці ніж 'b'
```

**<** - меньше логіка така сама

```python
result = 5 < 3  # значення змінної буде False
another_result = 3 < 5  # значення змінної буде True
compare_the_same_values = 3 < 3  # значення змінної буде False
small_value = 4
big_value = 6
compare_variables = big_value < small_value  # значення змінної буде False
compare_variables = small_value < big_value  # значення змінної буде True
compare_strings = 'ab' < 'baa'  # значення змінної буде True
```

**>=** - більше чи дорівнює

```python
result = 5 >= 3  # значення змінної буде True
another_result = 3 >= 5  # значення змінної буде False
compare_the_same_values = 3 >= 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value >= small_value  # значення змінної буде True
compare_variables = small_value >= big_value  # значення змінної буде False
compare_strings = 'ab' >= 'baa'  # значення змінної буде False
```

**<=** - меньше чи дорівнює

```python
result = 5 <= 3  # значення змінної буде True
another_result = 3 <= 5  # значення змінної буде False
compare_the_same_values = 3 <= 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value <= small_value  # значення змінної буде False
compare_variables = small_value <= big_value  # значення змінної буде True
compare_strings = 'ab' <= 'baa'  # значення змінної буде True
```

**==** - дорівнює

```python
result = 5 == 3  # значення змінної буде False
another_result = 3 == 5  # значення змінної буде False
compare_the_same_values = 3 == 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value == small_value  # значення змінної буде False
compare_variables = small_value == big_value  # значення змінної буде False
compare_strings = 'ab' == 'baa'  # значення змінної буде False
```

#### Ключові слова булевої алгебри в python

**and** - логічне **і**, **ПОВЕРТАЄ НЕ БУЛЬОВЕ ЗНАЧЕННЯ**

Логічне і працює так. Якщо **усі** значення у виразі є істиною результат також буде істиною. Але майте на увазі це
ключове слово не повертає булеан, воно повертає перше значення яке при перетворенні на булеан буде мати значення фолс,
або останнє якщо обидва тру. Давайте краще подивимося приклади.

Логічному і та логічному або можна передавати різні типи даних зліва та справа.

```python
True and True  # True
False and True  # False
False and False  # False
True and False  # False
True and ''  # ''
'a' and 0  # 0
0 and ''  # 0
10 and ''  # ''
'bla' and 23  # 23
```

**or** - логічне **або**, **ПОВЕРТАЄ НЕ БУЛЬОВЕ ЗНАЧЕННЯ**

Логічне або працює так. Якщо **одне** значення у виразі є істиною результат також буде істиною. Але майте на увазі це
ключове слово не повертає булеан, воно повертає перше значення яке при перетворенні на булеан буде мати значення тру,
або останнє якщо обидва фолс. Давайте краще подивимося приклади.

```python
True or True  # True
False or True  # True
False or False  # False
True or False  # True
True or ''  # True
'a' or 0  # 'a'
0 or ''  # ''
10 or ''  # 10
'bla' or 23  # 'bla'
```

**not** - перетворює True на False, та навпаки. Спочатку перетворює значення на булеан, а потім змінює на протилежне

```python
not True  # False
not False  # True
not ''  # True
not 33  # False
```

**in** - пошук підколекції в колекції. На цьому рівні знань використовується для пошуку входження однієї строки до
іншої:

```python
'ab' in 'bcde'  # False
'ab' in 'abcd'  # True
```

**is** - **ВИКОРИСТОВУЄТЬСЯ ЛИШЕ ЗІ ЗМІННИМИ**, це перевірка чи дві змінні знаходяться у одному й тому ж самому місці у
памʼяті. Це трохи складно для розуміння, і буде набагато простіше це пояснити коли ви будете знати інші типи даних. Але
поясню на деяких прикладах:

```python
a = 500
b = 500
a is b  # False
c = 500
d = c
c is d  # True
```

Але у пайтона є одна особливість щодо роботи цього оператора. Розробники мови програмування вирішили, що числа від -5 до
255 використовуються дуже часто і нема ніякого сенсу створювати для цих чисел нову змінну кожного разу. Тому вони
зробили так щоб при запуску скрипта значення між -5 до 255, бралися з внутрішньої памʼяті, через це є дуже цікавий
еффект, і я дуже полюбляю питати про це на співбесідах.

```python
a = 200
b = 200
a is b  # True
a = 300
b = 300
a is b  # False
```

Так працює до у першому випадку значення і в а і в б взяте з внутрішньої памʼяті, а у другому обидва значення просто
створюються.

### Розбираємося з пріоритетом операторів

Насправді як і в звичайній математиці у будь-яких операторів є свій приоритет. У нашій мові програмування він такий:

Деякі з цих операторів ми не вивчали, і вони використовуються набагато меньше, але якщо ви хочете, ви можете їх вивчити,
чи запитати викладачів.

**()** - дужки

** - ступінь

**+x, -x, ~x** Унарні плюс, мінус и бітове ні

*, /, //, % - помножити, розділити, розділити без залишку, залишок від ділення

**+, -** Додавання та віднімання

**<<, >>**    Бітові сдвиги

**&** Бітове і

**^** Бітове відʼемне або (XOR)

**|** Бітове або

**==, !=, >, >=, <, <=, is, is not, in, not in** - математика та входження/зрівняння

**not** Логічне НІ

**and** Логічне Так

**or** Логічне Або

Якщо вам потрібно змінити пріорітет виконання, просто використовуйте дужки

### Приклади

Будь-які з цих операцій можна комбінувати:

```python
age = int(input('Please enter your age:'))
name = input('Please enter your name:')

age > 18 and 'v' not in name.lower()
age < 10 or name == 'Kate'
age // 3 == 1 and len(name) > 4 or str(age) in name
```

## if, elif, else або навіщо це все треба

В програмуванні є декілька дуже базових концепцій, одна з них це розгалуження

Дуже просто, виконувати блок коду лише якщо умова є істиною.

В пайтоні для позначення блоків коду ми використовуємо звичайні відступи. В багатьох мовах програмування використовують
для цього різні дужки. У нас використовується 4 пробіли (на більшості компʼютерів кнопка tab працює саме як 4 пробіла)

### if

Зараз мі розглянемо ключові слова **if**, **elif**, **else**, але в пайтоні будь які структури які ви будете вивчати
далі використовують такий самий синтаксіс з чотирьма пробілами (або 1 табом)

```python
a = 100
b = 'bla'
if a:
    print('will be printed')
if a > 50:
    print('will be printed')
if 'c' in b:
    print('wont be printed')
```

Коли нам потрібно добавити умову, ми просто пишемо ключове слово **if** після нього ми вказуемо умову та ставимо
двокрапку. Все що мае виконуватися за умови має бути описане нижче зі зміщенням у 4 пробіли. Все що буде написано знову
на попередньому рівні буде виконане без умов.

### else

Якщо нам потрібно розбити виконання коду на те що робити коли умова виконується і коли ні ми можемо використати ключове
слово **else**

```python
a = 100
if a > 200:
    print('wont be printed')
else:
    print('will be printed')
```

### elif

також ми можемо додати проміжних умов якщо не виконався перший іф за допомогую **elif** який також потребує умови:

```python
a = 80
if a > 100:
    print('wontbe printed')
elif a > 50:
    print('will be printed')
else:
    print('wont be printed')
```

Насправді це просто синтаксічне спрощення такої конструкції

```python
a = 80
if a > 100:
    print('wontbe printed')
else:
    if a > 50:
        print('will be printed')
    else:
        print('wont be printed')
```

## match case

Тільки з версії 3.10 у пайтон додали ще одну можливість використовувати булеву алгебру. В багатьох інших мовах ця
конструкція називається switch case.

Ідея у тому, що ми можемо задати декілька опцій для перевірки нашої змінної і виконати лише ті де наша перевірка буде
тру.

```python
status = 400
match status:
    case 400:
        print("Bad request")
    case 401:
        print("Unauthorized")
    case 403:
        print("Forbidden")
    case 404:
        print("Not found")
```

Буде надруковано Bad request, бо наша перевірка зупиниться на версії status == 400. Ця конструкція має дуже багато
деталей та тонкощів, якщо захочете можете розібрати це самостійно, але моя практика каже що вона використовується рідко.

Практика/Домашне завдання:

1. Користувач задає змінну вік. Якщо він старше ніж 18 роздрукуйте що все добре, якщо ні, то роздрукуйте що не все добре
2. Додати до першої умови, якщо вік більше ніж 100, роздрукувати текст що користувач вводить нас в оману
3. Додати прінти чи є введений вік парним, чи непарним.
4. Додати що користувач вводить ще й ім'я. І якщо в імені є літера 'a', то написати що ми навідь не збираємося його
   перевіряти.
5. Перевірити якщо в імені є літера 'v' чи велика, чи маленька байдуже. І вік користувача парний, то написати що він
   виграв приз, якщо ні, то не виграв.

6. Спитати користувача вік, стать та ім'я. Для усіх молодше 15 ми пишемо що рекомендуємо теніс, для хлопців старше 15
   рекомендуємо футбол, для дівчат баскетбол, але якщо в імені є літера 'c' або 't', друкуємо що ми не рекомендуємо
   займатися спортом
